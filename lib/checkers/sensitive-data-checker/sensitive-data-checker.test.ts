import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import * as execModule from '../../utils/exec-sync';
import { exec } from '../../utils/exec-sync';
import { removeFile } from '../../utils/fs';
import { NpmVersionInfo } from '../../utils/npm-infos';
import { PackageDotJson } from '../../utils/read-package-json';
import { ValidationError } from '../common/checker-interface';
import { createPackageAndReadAsJson, ejectSensitiveData, NpmPackageInfos, sensitiveDataChecker } from './index';

let nativeProcessArgv: string[];
let tempFolder: string;
let nativeCwd: string;
let execSpy: jest.Mock<(command: string) => string>;

beforeAll(() => {
  nativeCwd = process.cwd();
  nativeProcessArgv = process.argv;
  tempFolder = join(__dirname, 'tmp');
  exec(`npm run rimraf -- ${tempFolder}`);
  mkdirSync(tempFolder);
});
beforeEach(() => {
  process.chdir(tempFolder);

  const pkg: Partial<PackageDotJson> = { name: 'testing-repo', version: '1.0.0', scripts: {} };
  const pkgFilepath = join(tempFolder, 'package.json');
  writeFileSync(pkgFilepath, JSON.stringify(pkg, null, 2));

  execSpy = jest.spyOn(execModule, 'exec').mockImplementation(() => {
    const npmInfo: NpmVersionInfo = { npm: '5.9.0', node: '9.2.0' };
    return JSON.stringify(npmInfo, null, 2);
  });

  // remove all files generated by a previous test run
  removeFile('testing-repo-1.0.0.tgz').fromDirectory(tempFolder);
  removeFile('foo.test.js').fromDirectory(tempFolder);
  removeFile('.sensitivedata').fromDirectory(tempFolder);

  // remove any errors and warnings in Checker
  sensitiveDataChecker.errors = undefined;
  sensitiveDataChecker.warnings = undefined;
  sensitiveDataChecker.hasErrors = undefined;
  sensitiveDataChecker.hasWarnings = undefined;
});
afterEach(() => {
  execSpy.mockRestore();
  process.chdir(nativeCwd);
  process.argv = nativeProcessArgv;
});
test('It should run when npm version >= 5.9.0', () => {
  // Given
  const checker = sensitiveDataChecker;

  // When
  const result = checker.canRun && checker.canRun();

  // Then
  expect(result).toBe(true);
});

test('It should not run when npm version < 5.9.0', () => {
  // Given
  const checker = sensitiveDataChecker;

  execSpy = jest.spyOn(execModule, 'exec').mockImplementation(() => {
    const npmInfo: NpmVersionInfo = { npm: '5.8.0', node: '8.6.0' };
    return JSON.stringify(npmInfo, null, 2);
  });

  // When
  const result = checker.canRun && checker.canRun();
  const explanation = checker.whyCannotRun && checker.whyCannotRun();

  // Then
  expect(result).toBe(false);
  expect(explanation).toContain('Cannot check sensitive and non-essential data because');
});

test('It should create a package file and read it as json', () => {
  // Given
  execSpy.mockRestore();
  const checker = sensitiveDataChecker;
  const testFileContent = 'foo';
  const testFilepath = join(tempFolder, 'foo.test.js');
  writeFileSync(testFilepath, testFileContent);

  // When
  const result = checker.canRun && checker.canRun() && createPackageAndReadAsJson();

  // Then
  const expectedResult = [
    {
      entryCount: 2,
      filename: 'testing-repo-1.0.0.tgz',
      files: [{ path: 'package.json' }, { path: 'foo.test.js' }],
      id: 'testing-repo@1.0.0',
      name: 'testing-repo',
      version: '1.0.0',
    },
  ] as Array<Partial<NpmPackageInfos>>;
  // tslint:disable-next-line:no-unused-expression
  checker.canRun && checker.canRun() && expect(result).toMatchObject(expectedResult);
});

test('It should create a package file and read it as json even when there is a pre-publish script', () => {
  // Given
  execSpy.mockRestore();
  const checker = sensitiveDataChecker;
  const testFileContent = 'foo';
  const testFilepath = join(tempFolder, 'foo.test.js');
  writeFileSync(testFilepath, testFileContent);

  const pkg: Partial<PackageDotJson> = {
    name: 'testing-repo',
    scripts: {
      prepublish: 'echo "running pre-publish script..."',
    },
    version: '1.0.0',
  };
  const pkgFilepath = join(tempFolder, 'package.json');
  writeFileSync(pkgFilepath, JSON.stringify(pkg, null, 2));

  // When
  const result = checker.canRun && checker.canRun() && createPackageAndReadAsJson();

  // Then
  const expectedResult = [
    {
      entryCount: 2,
      filename: 'testing-repo-1.0.0.tgz',
      files: [{ path: 'package.json' }, { path: 'foo.test.js' }],
      id: 'testing-repo@1.0.0',
      name: 'testing-repo',
      version: '1.0.0',
    },
  ] as Array<Partial<NpmPackageInfos>>;
  // tslint:disable-next-line:no-unused-expression
  checker.canRun && checker.canRun() && expect(result).toMatchObject(expectedResult);
});

test('It should throw an error when log file cannot be parsed to json', () => {
  // Given
  execSpy.mockRestore();
  const checker = sensitiveDataChecker;

  if (checker.canRun && checker.canRun()) {
    // When
    const spy = jest.spyOn(global.JSON, 'parse').mockImplementation(() => {
      throw new Error('yo');
    });

    // Then
    const expectedError = /^cannot parse to JSON the content of file.*$/;
    expect(() => createPackageAndReadAsJson()).toThrowError(expectedError);
    spy.mockRestore();
  }
});

test('It should run without error', () => {
  // Given
  execSpy.mockRestore();
  const checker = sensitiveDataChecker;

  // When
  const result = checker.canRun && checker.canRun() && checker.run && checker.run();

  // Then
  // tslint:disable-next-line:no-unused-expression
  checker.canRun && checker.canRun() && expect(result).toEqual([]);
});

test('It should run with error', () => {
  // Given
  execSpy.mockRestore();
  const checker = sensitiveDataChecker;

  const testFileContent = 'foo';
  const testFilepath = join(tempFolder, 'foo.test.js');
  writeFileSync(testFilepath, testFileContent);

  // When
  const result = checker.canRun && checker.canRun() && checker.run && checker.run();

  // Then
  const expectedResult: ValidationError = {
    reason: 'Sensitive or non essential data found in npm package: foo.test.js',
    severity: 'error',
  };
  // tslint:disable-next-line:no-unused-expression
  checker.canRun && checker.canRun() && expect(result).toEqual([expectedResult]);
});

test('It should remove the generated tarball file', () => {
  // Given
  execSpy.mockRestore();
  const checker = sensitiveDataChecker;

  // When
  // tslint:disable-next-line:no-unused-expression
  checker.canRun && checker.canRun() && checker.run && checker.run();

  // Then
  const expectedTarballFile = join(tempFolder, 'testing-repo-1.0.0.tgz');
  const fileExists = existsSync(expectedTarballFile);
  // tslint:disable-next-line:no-unused-expression
  checker.canRun && checker.canRun() && expect(fileExists).toBe(false);
});

test('It should eject the `.sensitivedata` file when file does not exists in  target directory', () => {
  // Given
  execSpy.mockRestore();
  const expectedFile = join(tempFolder, '.sensitivedata');
  let fileExists = existsSync(expectedFile);
  expect(fileExists).toBe(false);

  // When
  ejectSensitiveData();

  // Then
  fileExists = existsSync(expectedFile);
  expect(fileExists).toBe(true);
});

test('It should not eject the `.sensitivedata` file when file already exists in target directory', () => {
  // Given
  execSpy.mockRestore();
  const testFileContent = 'foo';
  const expectedFile = join(tempFolder, '.sensitivedata');
  writeFileSync(expectedFile, testFileContent);

  // When
  ejectSensitiveData();
  const result = readFileSync(expectedFile).toString();

  // Then
  expect(result).toBe('foo');
});
